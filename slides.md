---
layout: section
---

## Архітектурні принципи проектування розподілених інформаційних систем

Архітектура, орієнтована на  події

---
    layout: center
---

**Архітектура, орієнтована на  події** (Event-Driven Architecture, EDA) — шаблон архітектури програмного забезпечення, який призначений для створення подій, їх виявлення, споживання і реагування на них.

***Подія*** може бути визначена як важлива зміна стану системи або її компонентів, що потребує певної реакції. З формальної точки зору, те, що виробляється, публікується, поширюється, виявляється і споживається (як правило, асинхронно) є ***повідомленням***, яке називають сповіщенням про подію (або нотифікацією), а не самою подією, яка є зміною стану, що викликає появу повідомлення. Події не подорожують, вони просто відбуваються. 

Цей архітектурний шаблон може застосовуватися при проектуванні і реалізації застосунків і систем, які передають події між слабкозв'язаними компонентами програмного забезпечення і сервісами (службами).


---

## Архітектура, орієнтована на  події 

&nbsp;

EDA складається з ***емітерів*** подій (або агентів) і споживачів подій (або стоків). ***Стоки*** несуть відповідальність за здійснення реагування на подію. 

Реакція не завжди може бути повністю забезпечена самим стоком. Наприклад, стік, може бути відповідальним лише за фільтрацію, трансформацію і відправку повідомлення до іншого компонента, або він може забезпечити повністю самостійну реакцію на таку подію. 

Перша категорія стоків може бути заснована на традиційних компонентах, таких як проміжне програмне забезпечення, орієнтоване на обробку повідомлень (Message Oriented Middleware, MOM), в той час, як друга категорія стоків (самостійна реакція в режимі онлайн) може вимагати більш придатної платформи (фреймворку) для виконання транзакцій.

---

## Архітектура, орієнтована на  події 


Зазвичай повідомлення складається з двох частин: заголовка та тіла. Заголовок може включати в себе інформацію таку як, наприклад, назва події, часова мітка події і тип події. Тіло — це частина, яка описує факт, що стався в дійсності. Тіло не слід плутати з шаблоном або логікою, яка може бути застосована як реакція на саме повідомлення.
Наприклад, така структура повідомлення використовується в проекті [Сloudevents](https://cloudevents.io/), мета якого уніфікація способів визначення повідомлень та досягнення широких можливостей інтеграції ресурсів в глобальних розподлілених системах.

```json
{
  "specversion":"0.3",
  "type":"com.github.pull.create",
  "source":"https://github.com/cloudevents/spec/pull/123",
  "id":"70d3c768-63f8-40e7-aa9d-d197d530586b",
  "time":"2019-07-04T17:31:00Z",
  "datacontenttype":"application/json",
  "data":{
    "much":"wow"
  },
  "myextension" : {
    "some" : "thing"
  }
}
```

---

## Архітектура, орієнтована на  події 

<br/>

EDA складається з чотирьох логічних рівнів (шарів). Вона починається з виявлення факту, його технічного подання у формі повідомлення і закінчується непустою множиною реакцій на цю подію:
- ***Генератор подій***
- ***Канал подій***
- ***Механізм обробки подій***
- ***Післядія***

---
    layout: two-cols
---

<center style="
    border-radius:4px;
    border: 1px solid #cfd7e6;
    box-shadow: 0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025);
    padding: 1em;
    margin:2em;"
>

@startuml

participant Producer

participant MOM as "Event Processing"

participant Consumer

Producer -> MOM : primary event
MOM -> MOM: Event Processing
MOM -> Consumer: processed event
Consumer -> Consumer: action

@enduml

</center>


::right::

## Архітектура, орієнтована на  події 


***Генератор подій***. Першим логічним шаром є генератор подій, який виявляє факт і представляє цей факт подією. Оскільки фактом може бути практично все, що може бути сприйнято, то ним може бути і генератор подій. Наприклад, генератором може бути клієнт електронної пошти, система електронної комерції або певний тип датчика. Перетворення різних даних, отриманих від датчиків, в єдину стандартизовану форму повідомлень є основною проблемою при розробці та реалізації цього шару. Однак, враховуючи, що повідомлення є строго декларативним, можна легко застосовувати будь-які операції трансформації, тим самим усуваючи необхідність забезпечення високого рівня стандартизації.


---
    layout: two-cols
---

<center style="
    border-radius:4px;
    border: 1px solid #cfd7e6;
    box-shadow: 0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025);
    padding: 1em;
    margin:2em;"
>

@startuml

participant Producer

participant MOM as "Event Processing"

participant Consumer

Producer -> MOM : primary event
MOM -> MOM: Event Processing
MOM -> Consumer: processed event
Consumer -> Consumer: action

@enduml

</center>


::right::

## Архітектура, орієнтована на  події 


***Канал подій***. Канал подій — це механізм, через який повідомлення від генератора подій передається до обробника подій (стоку). Це може бути з'єднання TCP/IP або вхідний файл будь-якого типу (простий текст, формат XML, e-mail тощо). В один і той же час може бути відкрито кілька каналів подій. Оскільки обробник подій повинен працювати в режимі, наближеному до реального часу, канали подій зчитуються асинхронно. Події зберігаються в черзі каналу, очікуючи наступної обробки механізмом обробки подій.

---
    layout: two-cols
---

<center style="
    border-radius:4px;
    border: 1px solid #cfd7e6;
    box-shadow: 0 1px 3px 0 rgba(89,105,129,.05), 0 1px 1px 0 rgba(0,0,0,.025);
    padding: 1em;
    margin:2em;"
>

@startuml

participant Producer

participant MOM as "Event Processing"

participant Consumer

Producer -> MOM : primary event
MOM -> MOM: Event Processing
MOM -> Consumer: processed event
Consumer -> Consumer: action

@enduml

</center>


::right::

## Архітектура, орієнтована на  події 


***Механізм обробки подій***. Механізм обробки подій є місцем, де подія ідентифікується і вибирається відповідна реакція на нього, яка потім виконується. Це також може призвести до породження низки дій.


***Післядія***.  Наслідки події можуть проявитись багатьма різними способами і у різноманітних формах (наприклад, відправлення комусь повідомлення електронною поштою, вивід деякого попередження на екран, тощо.


---

## Архітектура, орієнтована на  події 

<br/>

Є три основні стилі оброблення повідомлень: 
- простий 
- потоковий
- складний. 
 
Часто всі ці три стилі комбінуються в EDA-системах.

---

## Архітектура, орієнтована на  події 

<br/>

***Просте оброблення повідомлень*** стосується визначених подій (notable events) - простих подій, для яких визначена післядія. Просте оброблення зазвичай використовується для управління потоком робіт в реальному часі, скорочуючи тим самим час затримки і вартість робіт.

При ***обробленні потоку подій*** прості події перевіряються на те, чи є вони визначеними, і, якщо післядія відома, передаються інформаційним підписникам. Обробка потоку подій зазвичай використовується для моніторингу та управління потоком інформації в реальному часі і на рівні підприємства, що дозволяє своєчасно приймати рішення.


---

## Архітектура, орієнтована на  події 

<br/>

***Оброблення складних подій*** дозволяє за шаблонами простих і визначених подій проводити аналіз того, чи сталася складна подія. 

Обробка складних подій полягає в оцінюванні взаємного впливу подій і в наступному виконанні дій. При цьому, типи подій можуть перетинатись, а події можуть виникати протягом тривалого періоду часу. Кореляція подій може бути причинною, тимчасовою або просторовою. 

Оброблення складних подій вимагає використання складних інтерпретаторів подій, визначення і підбору шаблонів подій, а також відповідних кореляційних методів. Оброблення складних подій зазвичай використовується для виявлення і реагування на аномальну поведінку, загрози і можливості у бізнесі.

---

## Архітектура, орієнтована на  події 

<br/>

***Advanced Message Queuing Protocol, AMQP*** —  відкритий протокол для передачі повідомлень між компонентами системи забезпечує можливості реалізації всіх стилей оброблення повідомлень. Основна ідея полягає в тому, що окремі підсистеми
можуть обмінюватися даними через AMQP-брокер, який здійснює маршрутизацію, можливо забезпечує гарантоване доставлення
повідомлень, розподілення потоків повідомлень, реалізовувати підписку на необхідні типи повідомлень.

---

## Архітектура, орієнтована на  події 

AMQP

***Повідомлення (message)*** — одиниця даних, що передаються. Основна його частина ніяк не інтерпретується сервером, до повідомлення можна приєднувати структуровані заголовки. 

***Producer*** - застосунок, який публікує повідомлення в exchange. Всі повідомлення відправляються в одну точку обміну, де перевіряються та перерозподіляються в черги.

***Consumer*** - застосунок, який отримує повідомлення з черги. Чегра повідомлень повинна бути готова до старта застосунку і повинна бути прив'язана до нього. Споживач може створювати.видаляти черги повідомлень, визначати спосіб заповннея черг за допомогою правил (bindings), вибирати різні точки обміну.

---

## Архітектура, орієнтована на  події 

AMQP

***Точка обміну (exchange)***, в яку відправляються повідомлення. Точка обміну розподіляє повідомлення в одну або декілька черг. Вона не зберігає повідомлення. Точки обміну бувають трьох типів:
- ***fanout*** — повідомлення передається у всі приєднані черги;
- ***direct*** — повідомлення передається в чергу з ім'ям, яке співпадає з ключем маршрутизації, який вказується під час відправлення повідомлення;
- ***topic*** — повідомлення передається в черги, для яких співпадає маска для ключа маршрутизації, наприклад, ```app.notification.sms.#``` — в чергу будуть доставлені повідомлення, відправлені з ключами, що починаються з ``` app.notification.sms```.
- ***Черга (queue)*** — сховище повідомлень, які зберігаються, поки не будуть забрані клієнтом. Клієнт забірає повідомлення з одної або декількох черг.

---

## Архітектура, орієнтована на  події 

AMQP

Коли застосунок створює чергу, може бути вказані:
- ```name``` - якщо не вказано, сервер сам обирає ім'я та відправляє його застосунку;
- ```exclusive``` - якщо цей параметр встановлено, черг існує поки існує поточне з'єднання. Після розриву з'єднання черга видаляється;
- ```durable``` - якщо встановлено, черга існує і активна після перезавантаження сервера. Однак черга може загубити повідомлення, що передавалися під час з'єднання.

Більшість інтеграційних архітектур використовують базову функціональність:
- базовий (default) exchange для відправників (producers) повідомлень;
- базовый binding для черг, який сортує повідомлення на основі співпадіння ім'я черги та ключа маршрутизації.


---

## Архітектура, орієнтована на  події 

AMQP

<center style="padding: 1em; margin: 0em 10em;">

@startuml

participant Producer
participant amqp as "AMQP client"
participant Connection
participant Channel

participant AMQP as "AMQP broker"

Producer -> amqp: connect
amqp -> AMQP
amqp <-- AMQP
create Connection
amqp -> Connection
Producer -> Connection : createChannel
create Channel
Connection -> Channel
Producer -> Channel: assertQueue
Channel -> AMQP: queue params
Channel <-- AMQP
Producer -> Channel: sendToQueue
Channel -> AMQP: message


@enduml

</center>

---

## Архітектура, орієнтована на  події 

AMQP


<center style="padding: 1em; margin:0 12em;">

@startuml
participant AMQP as "AMQP broker"
participant Channel
participant Connection
participant amqp as "AMQP client"

participant Consumer
participant Handler


Consumer -> amqp: connect
amqp -> AMQP
amqp <-- AMQP
create Connection
amqp -> Connection
Consumer -> Connection : createChannel
create Channel
Connection -> Channel
Consumer -> Channel: assertQueue
Channel -> AMQP: queue params
Channel <-- AMQP
create Handler
Consumer -> Handler
Consumer -> Channel: consume
Channel <- AMQP: message
Channel -> Handler
Handler -> Handler: handle event
Channel <- Handler: ask
Channel -> AMQP: ask
AMQP -> AMQP: delete message 



@enduml

</center>

